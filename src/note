



   sample_to_encode : int;
   predicted : int;
   residual : int;
   quantized : int;
   dequantized : int;
   reconstructed : int;

   qoa_scalefactor_tab : constant array (Positive) of Integer := (1, 7, 21, 45, 84, 138, 211,
                                                                    304, 421, 562, 731, 928, 1157,
                                                                    1419, 1715, 2048);
   qoa_dequant_tab : constant array (Positive) of Float := (0.75, -0.75, 2.5, -2.5, 4.5, -4.5, 7, -7)
   type Index_Range is range -8 .. 8;
   qoa_quant_tab : constant array Index_Range of Int := (7, 7, 7, 5, 5, 3, 3, 1, 0, 0, 2, 2, 4, 4, 6, 6, 6)

begin

   function qoa_lms_predict (lms : qoa_lms_t ) return Integer is
      prediction : Integer := 0;
   begin
      for i in range 0..QOA_LMS_LEN-1 loop
         prediction := prediction + lms->weights[i] * lms->history[i];
      end loop;
      return Shift_Right(prediction,13);
   end qoa_lms_predict;

   sample_to_encode := sample_data[si];
   predicted := qoa_lms_predict(&lms);
   residual := sample_to_encode - predicted;
   quantized := ;--/* quantize residual (explained later) */;
   dequantized := ; --/* dequantize quantized value */;
   reconstructed := qoa_clamp(predicted + dequantized, -32768, 32767);


   procedure qoa_lms_update ( lms : qoa_lms_t , reconstructed : int, residual : int) is
      delta : int := Shift_Right(residual,4);
   begin
      for i in range 0..QOA_LMS_LEN-1 loop
         if lms->history[i] < 0 then
            lms->weights[i] += -delta;
         else
            lms->weights[i] += -delta;
         end if;
      end loop;
      for i in range 0..QOA_LMS_LEN-1 loop
         lms->history[i] : = lms->history[i+1];
      end loop;
      lms->history[QOA_LMS_LEN-1] := reconstructed;
   end qoa_lms_update;



   qoa_lms_update(&lms, reconstructed, dequantized);
   
   
   
   
   
   function Read_u64 (Arr : Storage_Array; Index : in out Storage_Offet) return ... is
   
   begin
       Arr (Index + 1);
       
       Index := Index + 8;
   end Read_u64;
   
   
   Input : Storage_Array;
   Index : Storage_Offet := Input'First;
begin

   Val := Read_u64 (Input, Index);
   
   
